#include "../../../includes/stdlib.fc";
#include "../../../includes/common/context.fc";
#include "../../../includes/common/errors.fc";

#include "local/storage.fc";
#include "local/op_codes.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { 
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    load_storage();

    if (flags & 1) {        
        return ();
    }

    ctx::send_addr = cs~load_msg_addr();

    (ctx::opr, ctx::qryID) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    load_stg();

    ;; messages only from collection
    if equal_slices(ctx::send_addr, stg::collection_addr) {
        
        if ctx::opr == opr::add_token {

            (int amountA, int amountB) = (in_msg_body~load_coins(), in_msg_body~load_coins());

            stg::token_amountA += amountA;
            stg::token_amountB += amountB;

            if (stg::token_amountA) > 0 &  (stg::token_amountB > 0) {

                builder message =
                    begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(stg::collection_addr) 
                        .store_coins(0) 
                        .store_uint(0, 107)
                        .store_uint(opr::add_token_ok, 32)
                        .store_uint(ctx::qryID, 64)
                        .store_slice(stg::user_addr)
                        .store_coins(stg::token_amountA)
                        .store_coins(stg::token_amountB);

                send_raw_message(message.end_cell(), 64);

                stg::token_amountA = 0;
                stg::token_amountB = 0;
            }
            set_stg();
            return ();

        } elseif ctx::opr == opr::add_lp {
            
            set_stg();
            return ();
        } elseif ctx::opr == opr::add_swap {

            set_stg();
            return ();
        } 
    }

    throw(err::incr_opr);

}
