#include "../../../includes/stdlib.fc";
#include "../../../includes/common/context.fc";
#include "../../../includes/common/messages.func";

#include "modules/local/storage.fc";
#include "modules/local/errors.fc";
#include "modules/local/op_codes.fc";
#include "modules/local/token_utils.fc";
#include "modules/local/proxy_acc_utils.fc";
#include "modules/local/provide_lp_utils.fc";
#include "modules/local/swap_utils.fc";
#include "modules/local/onchain_info.fc";

;; provide_lp --> 
;; (init_addr + flow_label) 
;; flow_label = 0x111
;;
;; swap --> 
;; (init_addr + flow_label) 
;; flow_label = 0x222
;;
;; ask_lp --> 
;; (init_addr + flow_label) 
;; flow_label = 0x333


;; ATENTION!!!
;;
;; stable coin must be tokenB!!!

const int flow::provide_lp = 0x111;
const int flow::swap = 0x222;
const int flow::ask_lp = 0x333;
 
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { 
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {        
        return ();
    }

    ctx::send_addr = cs~load_msg_addr();

    (ctx::opr, ctx::qryID) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    load_stg();

    if ctx::opr == opr::add_token_ok {

        (slice user_addr, int amountA, int amountB) = (in_msg_body~load_msg_addr(), in_msg_body~load_coins(), in_msg_body~load_coins());

        ;; yes! now we have both of tokens. we must do swap, provide_lp and ask_lp

        ;; swap
        int amount_to_swap = (amountA * 20) / 100;
        must_swap(user_addr, amount_to_swap);

        ;; provide_lp   
        must_provide_lp(user_addr, amountA, amountB);

        ;; get onchain lp info about 20% of stake
        must_send_onchain_info_to_acc(ctx::qryID, user_addr, amountA, amountB, 30000000); ;; 0.03 TON as ton amount

        return ();
    }

    if ctx::opr == opr::only_ask {
        ;; penultimate transaction circle!!!
        slice slied_payload_ref = in_msg_body~load_ref().begin_parse();

        slice user_addr = slied_payload_ref~load_msg_addr();
        int onchain_info_lp_amount = slied_payload_ref~load_coins();

        ;; ask_lp
        must_ask_lp(user_addr, onchain_info_lp_amount, ctx::qryID);
    }

    if ctx::opr == opr::user_done {
        
        slice slied_payload_ref = in_msg_body~load_ref().begin_parse();

        (
            slice user_addr, 
            int amountA, 
            int amountB,
            int swapped_amount,
            int lp_tokens_amount,
            int asked_lp_amount) = (slied_payload_ref~load_msg_addr(), slied_payload_ref~load_coins(), slied_payload_ref~load_coins(),  slied_payload_ref~load_coins(),  slied_payload_ref~load_coins(),  slied_payload_ref~load_coins());

        ;; yes x2!!! now we nedd to send 100% of lp tokens(80% provided and 20% asked) to user
        ;; and we need to deploy nft user's smc and transfer to NFT swapped_amount insurance 
        ;; and 20% of tokenB(stable coin) send to invest! (landing prot, staking, e.t.c)


        
        return ();
    }

    if ctx::opr == opr::basic::jetton_notify {

        (int jetton_amount, slice from_user, int has_ref) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr(), in_msg_body~load_uint(1));
        throw_unless(121, has_ref);

        slice ref_ds = in_msg_body~load_ref().begin_parse();
        int transferred_op = ref_ds~load_uint(32);

        ;; P20 logic 

        ;; collect jetton from user thorugh his acc to do hedge scheme later!
        if transferred_op == opr::make_hedge {

            slice token_wallet = ref_ds~load_msg_addr();
            
            (slice acc_addr, cell acc_si) = calc_proxy_account_addr_and_si(from_user, my_address(), stg::proxy_acc_code);

            builder msg_body = 
                begin_cell()
                    .store_uint(opr::add_token, 32)
                    .store_uint(ctx::qryID, 64);

            if (slice_hash(ctx::send_addr) > slice_hash(token_wallet)) {
                msg_body = msg_body.store_coins(jetton_amount);
                msg_body = msg_body.store_coins(0);
            } else {
                msg_body = msg_body.store_coins(0);
                msg_body = msg_body.store_coins(jetton_amount);
            }
            
            send_message_with_stateinit(0, acc_addr, acc_si, msg_body.end_cell(), CARRY_REMAINING_GAS);
            return ();
        }

        ;; actions catcher logic

        if transferred_op == opr::ask_done {
            slice user_addr = in_msg_body~load_msg_addr();
            slice user_proxy_acc_addr = calculate_user_proxy_account_address(user_addr, my_address(), stg::proxy_acc_code);

            cell message = 
                begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(user_proxy_acc_addr) 
                    .store_coins(0) 
                    .store_uint(0, 107)
                    .store_uint(opr::ask_lp)
                    .store_uint(ctx::qID, 64)
                    .store_coins(jetton_amount)
                .end_cell();

            send_raw_message(message, 64);
        }

        if transferred_op == flow::provide_lp {
            slice from_user_addr = ref_ds~load_msg_addr();
            slice user_proxy_acc_addr = calculate_user_proxy_account_address(from_user_addr, my_address(), stg::proxy_acc_code);

            cell message = 
                begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(user_proxy_acc_addr) 
                    .store_coins(0) 
                    .store_uint(0, 107)
                    .store_uint(opr::add_lp)
                    .store_uint(ctx::qryID, 64)
                    .store_coins(jetton_amount) ;; lp tokens amount
                .end_cell();
            send_raw_message(message, 64);
            return ();
        }

        if transferred_op == flow::swap {
            slice from_user_addr = ref_ds~load_msg_addr();
            slice user_proxy_acc_addr = calculate_user_proxy_account_address(from_user_addr, my_address(), stg::proxy_acc_code);

            cell message = 
                begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(user_proxy_acc_addr) 
                    .store_coins(0) 
                    .store_uint(0, 107)
                    .store_uint(opr::add_swap)
                    .store_uint(ctx::qryID, 64)
                    .store_coins(jetton_amount) ;; swapped amount
                .end_cell();
            send_raw_message(message, 64);
            return ();
        }
    }

    throw(0xffff);
}
